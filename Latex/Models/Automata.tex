\documentclass{article}
\usepackage{titlesec}
\usepackage{tikz}
\usetikzlibrary{automata,positioning}
\setcounter{secnumdepth}{4}
\titleformat{\paragraph}
{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
\titlespacing*{\paragraph}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

\begin{document}
\section{Automatas:}
\subsection{Accept words starting with two consecutive a's:}
$A = (\{q_0, q_a, q_{aa}, q_{fail}\}, \{a, b\}, \delta, {q_{aa}})$ \newline
\begin{tikzpicture}[shorten >=1pt,node distance=4cm,on grid,auto] 
   \node[state,initial] (q_0)   {$q_0$}; 
   \node[state] (q_a) [above right=of q_0] {$q_a$}; 
   \node[state] (q_{fail}) [below right=of q_0] {$q_{fail}$}; 
   \node[state,accepting](q_{aa}) [below right=of q_a] {$q_{aa}$};
    \path[->] 
    (q_0) edge node {a} (q_a)
          edge node {b} (q_{fail})
    (q_a) edge node {a} (q_{aa})
          edge node {b} (q_{fail})
    (q_{aa}) edge [loop below] node {{a,b}} () 
    (q_{fail}) edge [loop below] node {{a,b}} ();
\end{tikzpicture}
\newline
\subsection{Accept no words:}
$A = (\{q_0\}, \{a,b\}, \delta, \emptyset)$ \newline
\begin{tikzpicture}
  \node [state, initial] (q_0) {$q_0$};
    \path[->]
    (q_0) edge [loop above] node {{a,b}} ();
\end{tikzpicture}

\subsection{Accept all words:}
$A = (\{q_0\}, \{a,b\}, \delta, \Sigma^{*})$ \newline
\begin{tikzpicture}
  \node [state, initial, accepting] (q_0) {$q_0$};
    \path[->]
    (q_0) edge [loop above] node {{a,b}} ();
\end{tikzpicture}
\subsection{Only accept empty words ($\epsilon$):}
$A = (\{q_0, q_{fail}\}, \{a,b\}, \delta, \{\epsilon\})$ \newline
\begin{tikzpicture}
  \node [state, initial, accepting] (q_0) {$q_0$};
  \node [state] (q_{fail}) [right=of q_0]{$q_{fail}$};
  
    \path[->]
    (q_0) edge node {{a,b}} (q_{fail})
    (q_{fail}) edge [loop above] node {{a,b}} ();
\end{tikzpicture}
\subsection{Only accept words which have their odd characters set to a:}
$A = (\{q_{even}, q_{odd}, q_{fail}\}, \{a,b\}, \delta, \{\exists x \in \Sigma^{*} \exists y,z \in \Sigma \mid x = yz \wedge z = a\})$ \newline
\begin{tikzpicture}
  \node [state, initial, accepting] (q_0) {$q_0$};
  \node [state, accepting] (q_{even}) [above right=of q_0] {$q_{even}$};
  \node [state, accepting] (q_{odd}) [below right=of q_0] {$q_{odd}$};
  \node [state] (q_{fail}) [below right=of q_{even}] {$q_{fail}$};
    \path[->]
    (q_0) edge node {a} (q_{odd})
    (q_0) edge node {b} (q_{fail})
    (q_{even}) edge node {a} (q_{odd})
    (q_{even}) edge node {b} (q_{fail})
    (q_{odd}) edge node {{a,b}} (q_{even})
    (q_{fail}) edge [loop right] node {{a,b}} (q_{fail});
\end{tikzpicture}
\subsection{Only accept words which have their first character set differently than the last:}
$A = (\{q_{even}, q_{odd}, q_{fail}\}, \{a,b\}, \delta, \{x = wyz \mid w,z \in \Sigma \wedge y \in \Sigma^{*} \wedge w \neq z\})$ \newline
\begin{tikzpicture}
  \node [state, initial] (q_0) {$q_0$};
  \node [state] (q_{a_{first}}) [above=of q_0]{$q_{a_{first}}$};
  \node [state] (q_{b_{first}}) [below=of q_0]{$q_{b_{first}}$};
  \node [state, accepting] (q_a) [right=of q_{a_{first}}] {$q_a$};
  \node [state, accepting] (q_b) [right=of q_{b_{first}}] {$q_b$};
  \node [state] (q_{a_{fail}}) [below right=of q_a] {$q_{a_{fail}}$};
  \node [state] (q_{b_{fail}}) [above right=of q_b] {$q_{b_{fail}}$};
    \path[->]
    (q_0) edge node {a} (q_{a_{first}})
    (q_0) edge node {b} (q_{b_{first}})
    (q_{a_{first}}) edge node {a} (q_{a_{fail}})
    (q_{a_{first}}) edge node {b} (q_a)
    (q_{b_{first}}) edge node {b} (q_{b_{fail}})
    (q_{b_{first}}) edge node {a} (q_b)
    (q_a) edge node {a} (q_{a_{fail}})
    (q_a) edge [loop below] node {b} ()
    (q_b) edge node {b} (q_{b_{fail}})
    (q_b) edge [loop above] node {a} ()
    (q_{a_{fail}}) edge node {b} (q_a)
    (q_{b_{fail}}) edge node {a} (q_b);
\end{tikzpicture}
\subsection{Only accept words which contain the string aba:}
\begin{tikzpicture}
  \node [state, initial] (q_0) {$q_0$};
  \node [state] (q_1) [right=of q_0] {$q_1$};
  \node [state] (q_2) [right=of q_1] {$q_2$};
  \node [state, accepting] (q_3) [right=of q_2] {$q_3$};
  \node [state] (q_4) [below=of q_0] {$q_4$};
    \path[->]
    (q_0) edge node {a} (q_1)
    (q_0) edge node {b} (q_4)
    (q_1) edge node {b} (q_2)
    (q_1) edge node {a} (q_4)
    (q_2) edge node {b} (q_4)
    (q_2) edge node {a} (q_3)
    (q_3) edge [loop below] node {{a,b}} ()
    (q_4) edge node {a} (q_0);
\end{tikzpicture}
\subsection{Only accept words which do not contain the string aba:}
\begin{tikzpicture}
  \node [state, initial, accepting] (q_0) {$q_0$};
  \node [state, accepting] (q_1) [right=of q_0] {$q_1$};
  \node [state, accepting] (q_2) [right=of q_1] {$q_2$};
  \node [state] (q_3) [right=of q_2] {$q_3$};
  \node [state, accepting] (q_4) [below=of q_0] {$q_4$};
    \path[->]
    (q_0) edge node {a} (q_1)
    (q_0) edge node {b} (q_4)
    (q_1) edge node {b} (q_2)
    (q_1) edge node {a} (q_4)
    (q_2) edge node {b} (q_4)
    (q_2) edge node {a} (q_3)
    (q_3) edge [loop below] node {{a,b}} ()
    (q_4) edge node {a} (q_0);
\end{tikzpicture}
\subsection{Only accept words which are numbers divisible by 3:}
\begin{tikzpicture}
  \node [state, initial] (q_{start}) {$q_{start}$};
  \node [state, accepting] [above=of q_{start}] (q_0) {$q_0$};
  \node [state, accepting] (q_1) [below left=of q_{start}] {$q_1$};
  \node [state, accepting] (q_2) [below right=of q_{start}] {$q_2$};
    \path[->]
    (q_{start}) edge node {{1,4,7}} (q_1)
    (q_{start}) edge node {{2,5,8}} (q_2)
    (q_{start}) edge node {{3,6,9}} (q_0)
    (q_0) edge node {{1,4,7}} (q_1)
    (q_0) edge node {{2,5,8}} (q_2)
    (q_0) edge [loop above] node {{0,3,6,9}} ()
    (q_1) edge node {{1,4,7}} (q_2)
    (q_1) edge node {{2,5,8}} (q_0)
    (q_1) edge [loop left] node {{0,3,6,9}} ()
    (q_2) edge node {{1,4,7}} (q_0)
    (q_2) edge node {{2,5,8}} (q_1)
    (q_2) edge [loop right] node {{0,3,6,9}} ();
\end{tikzpicture}
\subsection{Only accept words which's length is divisible by 3:}
\begin{tikzpicture}
  \node [state, initial] (q_{start}) {$q_{start}$};
  \node [state, accepting] [above=of q_{start}] (q_0) {$q_0$};
  \node [state] (q_1) [below left=of q_{start}] {$q_1$};
  \node [state] (q_2) [below right=of q_{start}] {$q_2$};
    \path[->]
    (q_{start}) edge node {$\sigma \in \Sigma$} (q_1)
    (q_0) edge node {$\sigma \in \Sigma$} (q_1)
    (q_1) edge node {$\sigma \in \Sigma$} (q_2)
    (q_2) edge node {$\sigma \in \Sigma$} (q_0);
\end{tikzpicture}
\subsection{Only accept words which have a length such that it returns 1 when paired with modulu 3:}
\begin{tikzpicture}
  \node [state, initial] (q_{start}) {$q_{start}$};
  \node [state] [above=of q_{start}] (q_0) {$q_0$};
  \node [state, accepting] (q_1) [below left=of q_{start}] {$q_1$};
  \node [state] (q_2) [below right=of q_{start}] {$q_2$};
    \path[->]
    (q_{start}) edge node {$\sigma \in \Sigma$} (q_1)
    (q_0) edge node {$\sigma \in \Sigma$} (q_1)
    (q_1) edge node {$\sigma \in \Sigma$} (q_2)
    (q_2) edge node {$\sigma \in \Sigma$} (q_0);
\end{tikzpicture}
\subsection{Only accept words which have a length such that it does not return 1 when paired with modulu 3:}
\begin{tikzpicture}
  \node [state, initial] (q_{start}) {$q_{start}$};
  \node [state, accepting] [above=of q_{start}] (q_0) {$q_0$};
  \node [state] (q_1) [below left=of q_{start}] {$q_1$};
  \node [state, accepting] (q_2) [below right=of q_{start}] {$q_2$};
    \path[->]
    (q_{start}) edge node {$\sigma \in \Sigma$} (q_1)
    (q_0) edge node {$\sigma \in \Sigma$} (q_1)
    (q_1) edge node {$\sigma \in \Sigma$} (q_2)
    (q_2) edge node {$\sigma \in \Sigma$} (q_0);
\end{tikzpicture}
\subsection{Only accept words which begin with 5 consecutive ba's and end with an abb:}
\begin{tikzpicture}
  \node [state, initial] (q_0) {$q_0$};
  \node [state] [right=of q_0] (q_{fail}) {$q_{fail}$};
  \node [state] [below=of q_0] (q_b) {$q_b$};
  \node [state] [right=of q_b] (q_a) {$q_a$};
  \node [state] [below=of q_a] (q_{b_2}) {$q_{b_2}$};
  \node [state] [right=of q_{b_2}] (q_{a_2}) {$q_{a_2}$};
  \node [state] [below=of q_{a_2}] (q_{b_3}) {$q_{b_3}$};
  \node [state] [right=of q_{b_3}] (q_{a_3}) {$q_{a_3}$};
  \node [state] [below=of q_{a_3}] (q_{b_4}) {$q_{b_4}$};
  \node [state] [right=of q_{b_4}] (q_{a_4}) {$q_{a_4}$};
  \node [state] [below=of q_{a_4}] (q_{b_5}) {$q_{b_5}$};
  \node [state] [right=of q_{b_5}] (q_{abb_{a}}) {$q_{abb_{a}}$};
  \node [state] [right=of q_{abb_{a}}] (q_{abb_{b}}) {$q_{abb_{b}}$};
  \node [state, accepting] [right=of q_{abb_{b}}] (q_{abb_{b_{2}}}) {$q_{abb_{b_{2}}}$};
  \node [state] [below=of q_{abb_{b}}] (q_{abb_{0}}) {$q_{abb_{0}}$};
    \path[->]
    (q_0) edge node [above] {a} (q_{fail})
    (q_0) edge node [left] {b} (q_b)
    (q_{fail}) edge [loop right] node [right] {{a,b}} ()
    (q_b) edge node [above] {b} (q_{fail})
    (q_b) edge node [above] {a} (q_a)
    (q_a) edge node [left] {b} (q_{b_2})
    (q_a) edge node [right] {a} (q_{fail})
    (q_{b_2}) edge [bend right] node [below right] {b} (q_{fail})
    (q_{b_2}) edge node [above] {a} (q_{a_2})
    (q_{a_2}) edge node [left] {b} (q_{b_3})
    (q_{a_2}) edge [bend right] node [right] {a} (q_{fail})
    (q_{b_3}) edge [bend right=50] node [below right] {b} (q_{fail})
    (q_{b_3}) edge node [above] {a} (q_{a_3})
    (q_{a_3}) edge node [left] {b} (q_{b_4})
    (q_{a_3}) edge [bend right] node [right] {a} (q_{fail})
    (q_{b_4}) edge [bend right=50] node [below right] {b} (q_{fail})
    (q_{b_4}) edge node [above] {a} (q_{a_4})
    (q_{a_4}) edge node [left] {b} (q_{b_5})
    (q_{a_4}) edge [bend right] node [right] {a} (q_{fail})
    (q_{b_5}) edge [bend right=50] node [below right] {b} (q_{fail})
    (q_{b_5}) edge node [above] {a} (q_{abb_{a}})
    (q_{abb_{a}}) edge node [above] {b} (q_{abb_{b}})
    (q_{abb_{a}}) edge [loop below] node [below] {a} ()
    (q_{abb_{b}}) edge [bend left] node [below] {a} (q_{abb_{a}})
    (q_{abb_{b}}) edge node [above] {b} (q_{abb_{b_{2}}})
    (q_{abb_{b_{2}}}) edge [bend left] node [above] {a} (q_{abb_{a}})
    (q_{abb_{b_{2}}}) edge node [below] {b} (q_{abb_{0}})
    (q_{abb_{0}}) edge [loop below] node [below] {b} ()
    (q_{abb_{0}}) edge node [below] {a} (q_{abb_{a}});
\end{tikzpicture}
\subsection{Only accept words which contain the letter a at least twice and no more than 1 of the letter b:}
\begin{tikzpicture}
  \node [state, initial] (q_0) {$q_0$};
  \node [state] [right=of q_0] (q_1) {$q_1$};
  \node [state, accepting] [right=of q_1] (q_2) {$q_2$};
  \node [state] [below=of q_0] (q_3) {$q_3$};
  \node [state] [right=of q_3] (q_4) {$q_4$};
  \node [state, accepting] [right=of q_4] (q_5) {$q_5$};
  \node [state] [below=of q_4] (q_6) {$q_6$};
    \path[->]
    (q_0) edge node [above] {a} (q_1)
    (q_0) edge node [left] {b} (q_3)
    (q_1) edge node [above] {a} (q_2)
    (q_1) edge node [left] {b} (q_4)
    (q_2) edge [loop right] node [right] {a} ()
    (q_2) edge node [left] {b} (q_5)
    (q_3) edge node [above] {a} (q_4)
    (q_3) edge node [below] {b} (q_6)
    (q_4) edge node [above] {a} (q_5)
    (q_4) edge node [left] {b} (q_6)
    (q_5) edge [loop right] node [right] {a} ()
    (q_5) edge node [below] {b} (q_6)
    (q_6) edge [loop below] node [below] {{a,b}} ();
\end{tikzpicture}
\end{document}  
